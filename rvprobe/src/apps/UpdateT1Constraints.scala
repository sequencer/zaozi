// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 Jianhao Ye <Clo91eaf@qq.com>
package me.jiuyang.rvprobe.apps

import me.jiuyang.rvprobe.*
import org.chipsalliance.rvdecoderdb.{Encoding, Instruction, InstructionSet}
import os.Path
import java.io.{File, FileWriter}

// Get Instruction json first in t1 repo:
// nix build .#t1.blastoise.t1emu.omreader
// ./result/bin/omreader | jq '{instructions}' > /tmp/instruction.json

// Run with: mill rvprobe.runMain me.jiuyang.rvprobe.apps.UpdateT1Constraints /tmp/instruction.json
// make sure git repo is clear before running this script
@main def UpdateT1Constraints(jsonPath: String): Unit =
  val writer = new FileWriter(new File("rvprobe/src/constraints/T1Constraints.scala"))

  writer.write(
    """// SPDX-License-Identifier: Apache-2.0
      |// SPDX-FileCopyrightText: 2025 Jianhao Ye <Clo91eaf@qq.com>
      |package me.jiuyang.rvprobe.constraints
      |
      |import me.jiuyang.smtlib.default.{*, given}
      |import me.jiuyang.smtlib.tpe.*
      |
      |import org.llvm.mlir.scalalib.capi.ir.{Block, Context, Location, LocationApi, Operation, Type, Value, given}
      |
      |import java.lang.foreign.Arena
      |
      |// format: off
      |// ================= AUTO GENERATED BY GenerateConstraints.scala =======================
      |""".stripMargin
  )

  val instructionsAttributes = parseJson(os.Path(jsonPath))
  instructionsAttributes.foreach { case (instructionName, (yesList, noList)) =>
    val positiveAttrs = yesList.map(a => s"is${a}()")
    val negativeAttrs = noList.map(a => s"is${a}()")

    val positiveConstraint = positiveAttrs.length match
      case 0 => ""
      case 1 => positiveAttrs.head
      case _ => positiveAttrs.mkString("smtOr(", ", ", ")")

    val negativeConstraint = negativeAttrs.length match
      case 0 => ""
      case 1 => negativeAttrs.head
      case _ => s"!smtOr(${negativeAttrs.mkString(", ")})"

    val rhs =
      if positiveConstraint.nonEmpty && negativeConstraint.nonEmpty then s"$positiveConstraint & $negativeConstraint"
      else if positiveConstraint.nonEmpty then positiveConstraint
      else if negativeConstraint.nonEmpty then negativeConstraint
      else "smtFalse" // fallback when no constraints; keeps generated file valid

    writer.write(
      s"def ${instructionName}()(using Arena, Context, Block, Index, Recipe): Ref[Bool] = $rhs\n"
    )
  }

  writer.close()

// Simplified types for attribute collections
case class AttrLists(yes: List[String] = Nil, no: List[String] = Nil):
  def merge(other: AttrLists): AttrLists = AttrLists(yes ++ other.yes, no ++ other.no)
  def addYes(v:    String):    AttrLists = copy(yes = yes :+ v)
  def addNo(v:     String):    AttrLists = copy(no = no :+ v)

def camelize(raw: String): String =
  raw
    .replace(".", "_")
    .split("[^a-zA-Z0-9]")
    .filter(_.nonEmpty)
    .map(_.capitalize)
    .mkString

def parseAttributeValue(id: String, v: ujson.Value): Either[String, (String, Boolean)] =
  v.str.toUpperCase match
    case "Y"   => Right((id, true))
    case "N"   => Right((id, false))
    case "DC"  => Left("DC")
    case other => throw new RuntimeException(s"Unknown value for attribute $id: $other")

def parseJson(filePath: os.Path): Map[String, (List[String], List[String])] =
  val jsonString = os.read(filePath)
  val json       = ujson.read(jsonString)

  val instrArr = json.obj.get("instructions") match
    case Some(a) => a.arr
    case None    => throw new RuntimeException("JSON missing 'instructions' field")

  // Accumulate a global map: attributeIdentifier -> AttrLists(yes, no)
  val global: Map[String, AttrLists] = instrArr.foldLeft(Map.empty[String, AttrLists]) { (gAcc, instr) =>
    val name      = instr.obj("instructionName").str.replace(".", "_")
    val camelName = camelize(name)

    val local: Map[String, AttrLists] =
      instr.obj.get("attributes") match
        case Some(attrs) =>
          attrs.arr.foldLeft(Map.empty[String, AttrLists]) { (lAcc, attr) =>
            val identifier = attr.obj("identifier").str
            attr.obj.get("value") match
              case Some(v) =>
                parseAttributeValue(identifier, v) match
                  case Right((id, isYes)) =>
                    val prev    = lAcc.getOrElse(id, AttrLists())
                    val updated = if isYes then prev.addYes(camelName) else prev.addNo(camelName)
                    lAcc.updated(id, updated)
                  case Left(_)            => lAcc // DC -> don't care, ignore
              case None    => throw new RuntimeException(s"Attribute $identifier has no value")
          }
        case None        => Map.empty

    // merge local into global
    local.foldLeft(gAcc) { case (acc, (k, v)) =>
      acc.updated(k, acc.getOrElse(k, AttrLists()).merge(v))
    }
  }

  // convert to original return type (List[String], List[String])
  global.view.mapValues(al => (al.yes, al.no)).toMap
