// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 Jiuyang Liu <liu@jiuyang.me>
package me.jiuyang.zaozi

import scala.annotation.targetName
import scala.util.chaining.*

import me.jiuyang.zaozi.magic.macros.summonLayersImpl
import me.jiuyang.zaozi.reftpe.*
import me.jiuyang.zaozi.valuetpe.*

import org.llvm.circt.scalalib.dialect.firrtl.operation.{ExtModule as CirctExtModule, Module as CirctModule, When}
import org.llvm.mlir.scalalib.capi.ir.{Block, Context, Operation, Type, Value}

import java.lang.foreign.Arena

/** Rebuild the [[Layer]] with each [[Layer]] contains the entire tree. */
trait LayerTree:
  layer =>
  def name:      String
  def children:  Seq[LayerTree]
  def parent:    Option[LayerTree] = None
  def hierarchy: Seq[LayerTree]    =
    parent match
      case Some(p) => p.hierarchy :+ this
      case None    => Seq(this)
  def _dfs:      Seq[LayerTree]    =
    this +: children.flatMap(_._dfs)
  def _rebuild:  LayerTree         =
    def rebuildLayer(_oldLayer: LayerTree, _parent: Option[LayerTree]): LayerTree =
      new LayerTree:
        override def name:     String            = _oldLayer.name
        override def children: Seq[LayerTree]    =
          _oldLayer.children.map(child => rebuildLayer(child, Some(this)))
        override def parent:   Option[LayerTree] = _parent
    rebuildLayer(this, None)

/** Serializable Layer definition. */
case class Layer(name: String, children: Seq[Layer] = Seq.empty):
  layer =>
  def toLayerTree: LayerTree =
    new LayerTree:
      def name:     String         = layer.name
      def children: Seq[LayerTree] = layer.children.map(_.toLayerTree)
    ._rebuild
extension (layers: Seq[Layer]) def toLayerTrees: Seq[LayerTree]   = layers.map(_.toLayerTree)
extension (layer:  LayerTree) def nameHierarchy = layer.hierarchy.map(_.name)
extension (layers: Seq[LayerTree])
  def nameHierarchies:                           Seq[Seq[String]] =
    layers.flatMap(_._dfs).filter(_.children.isEmpty).map(_.nameHierarchy)

abstract class Parameter                                    extends Product
abstract class LayerInterface[P <: Parameter](parameter: P) extends Seq[LayerTree]:
  def layers: Seq[Layer]

  final override def apply(idx: Int) = layers.toLayerTrees(idx)
  final override def iterator        = layers.toLayerTrees.iterator
  final override def length          = layers.toLayerTrees.length

trait HWInterface[P <: Parameter](parameter: P)       extends Aggregate:
  this: Bundle | Record =>
abstract class HWBundle[P <: Parameter](parameter: P) extends HWInterface(parameter) with Bundle
abstract class HWRecord[P <: Parameter](parameter: P) extends HWInterface(parameter) with Record

trait DVInterface[P <: Parameter, L <: LayerInterface[P]](parameter: P) extends Aggregate:
  this: ProbeBundle | ProbeRecord =>
  private var _layersOpt:              Option[L]         = None
  transparent inline def summonLayers: LayerInterface[?] = ${ summonLayersImpl }
  transparent inline def layers:       L                 = _layersOpt.getOrElse:
    summonLayers.asInstanceOf[L].tap(l => _layersOpt = Some(l))
abstract class DVBundle[P <: Parameter, L <: LayerInterface[P]](parameter: P)
    extends DVInterface[P, L](parameter)
    with ProbeBundle
abstract class DVRecord[P <: Parameter, L <: LayerInterface[P]](parameter: P)
    extends DVInterface[P, L](parameter)
    with ProbeRecord
class InstanceContext:
  class AnonSignalCounter(private var _count: Int):
    def count = _count
    def inc() =
      val o = count
      _count += 1
      o

  val anonSignalCounter = new AnonSignalCounter(0)

trait Generator[PARAM <: Parameter, L <: LayerInterface[PARAM], I <: HWInterface[PARAM], P <: DVInterface[PARAM, L]]:
  /* For traits with self-type annotation that don't want type parameters
     e.g
      trait SomeGenerator:
        this: Generator[?, ?, ?] =>
        private val self = this.asInstanceOf[Generator[this.TPARAM, this.TINTF, this.TPROBE]]
   */
  type TPARAM = PARAM
  type TLAYER = L
  type TINTF  = I
  type TPROBE = P

  def moduleName(parameter: PARAM): String =
    s"${this.getClass.getSimpleName.stripSuffix("$")}_${parameter.hashCode.toHexString}"

  def architecture(parameter: PARAM): (
    Arena,
    Context,
    Block,
    Interface[I],
    Interface[P],
    L,
    InstanceContext
  ) ?=> Unit

  private[zaozi] val elaboratedModules = scala.collection.mutable.HashSet.empty[PARAM]

  // fields should be generated by macro automatically
  def layers(parameter:    PARAM): L
  def interface(parameter: PARAM): I
  def probe(parameter:     PARAM): P

  def parseParameter(args: Seq[String]): PARAM

  def main(args: Array[String]): Unit

abstract class VerilogParameter extends Product

trait VerilogWrapper[
  PARAM <: Parameter,
  L <: LayerInterface[PARAM],
  I <: HWInterface[PARAM],
  P <: DVInterface[PARAM, L],
  V <: VerilogParameter]:
  type TPARAM  = PARAM
  type TLAYER  = L
  type TINTF   = I
  type TPROBE  = P
  type TVPARAM = V

  def verilogModuleName(parameter: PARAM): String

  // ensure that the moduleName is unique for each verilog parameter
  def moduleName(parameter: PARAM): String =
    s"${verilogModuleName(parameter)}_${verilogParameter(parameter).hashCode.toHexString}"

  def verilogParameter(parameter: PARAM): V

  private[zaozi] val elaboratedModules = scala.collection.mutable.HashSet.empty[PARAM]

  // fields should be generated by macro automatically
  def layers(parameter:    PARAM): L
  def interface(parameter: PARAM): I
  def probe(parameter:     PARAM): P

  def parseParameter(args: Seq[String]): PARAM

  def main(args: Array[String]): Unit

// No type params in trait for easy exporting
trait GeneratorApi:
  extension [PARAM <: Parameter, L <: LayerInterface[PARAM], I <: HWInterface[PARAM], P <: DVInterface[PARAM, L]](
    generator: Generator[PARAM, L, I, P]
  )
    private[zaozi] def module(
      parameter: PARAM
    )(
      using Arena,
      Context
    ): CirctModule

    private[zaozi] def instance(
      parameter: PARAM
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Instance[I, P]

    def instantiate(
      parameter: PARAM
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Instance[I, P]

    def dumpMlirbc(
      parameter: PARAM
    )(
      using Arena,
      Context
    ): Unit

    def mainImpl(
      args: Array[String]
    )(
      using upickle.default.ReadWriter[PARAM]
    ): Unit

trait VerilogWrapperApi:
  extension [
    PARAM <: Parameter,
    L <: LayerInterface[PARAM],
    I <: HWInterface[PARAM],
    P <: DVInterface[PARAM, L],
    V <: VerilogParameter
  ](wrapper: VerilogWrapper[PARAM, L, I, P, V]
  )
    private[zaozi] def instance(
      parameter: PARAM
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Instance[I, P]

    def instantiate(
      parameter: PARAM
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Instance[I, P]

trait ConstructorApi:
  def Clock(): Clock

  def Reset(): Reset

  def AsyncReset(): Reset

  def UInt(width: Width): UInt

  def Bits(width: Width): Bits

  def SInt(width: Width): SInt

  def Bool(): Bool

  def Vec[T <: Data](size: Int, tpe: T): Vec[T]

  def when[COND <: Referable[Bool]](
    cond: COND
  )(body: (Arena, Context, Block) ?=> Unit
  )(
    using Arena,
    Context,
    Block,
    sourcecode.File,
    sourcecode.Line
  ): When

  extension (when: When)
    def otherwise(
      body: (Arena, Context, Block) ?=> Unit
    )(
      using Arena,
      Context
    ): Unit

  def Wire[T <: Data](
    refType: T
  )(
    using Arena,
    Context,
    Block,
    sourcecode.File,
    sourcecode.Line,
    sourcecode.Name.Machine,
    InstanceContext
  ):   Wire[T]
  def Reg[T <: Data](
    refType: T
  )(
    using Arena,
    Context,
    Block,
    Ref[Clock],
    sourcecode.File,
    sourcecode.Line,
    sourcecode.Name.Machine,
    InstanceContext
  ):   Reg[T]
  def RegInit[T <: Data](
    input: Const[T]
  )(
    using Arena,
    Context,
    Block,
    Ref[Clock],
    Ref[Reset],
    sourcecode.File,
    sourcecode.Line,
    sourcecode.Name.Machine,
    InstanceContext
  ):   Reg[T]
  extension (bigInt: BigInt)
    def U(
      width: Width
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line
    ):     Const[UInt]
    def U(
      using Arena,
      Context,
      Block
    ):     Const[UInt]
    def B(
      using Arena,
      Context,
      Block
    ):     Const[Bits]
    def S(
      width: Width
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line
    ):     Const[SInt]
    def S(
      using Arena,
      Context,
      Block
    ):     Const[SInt]
    def W: Width
  extension (bool:   Boolean)
    def B(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line
    ): Const[Bool]
end ConstructorApi

trait AsBits[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def asBits(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[Bits]
trait AsBool[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def asBool(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[Bool]
trait AsSInt[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def asSInt(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[SInt]
trait AsUInt[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def asUInt(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[UInt]

trait AsBundle[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def asBundle[T <: Bundle](
      tpe: T
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[T]

trait AsRecord[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def asRecord[T <: Record](
      tpe: T
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[T]

trait AsVec[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def asVec[E <: Data](
      tpe: E
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[Vec[E]]

trait ProbeConnect[D <: Data & CanProbe, P <: RWProbe[D] | RProbe[D], DATA <: Referable[D], PROBE <: Referable[P]]:
  extension (ref: PROBE)
    @targetName("send")
    def <==(
      that: DATA
    )(
      using Arena,
      Context,
      Block,
      LayerTree,
      sourcecode.File,
      sourcecode.Line
    ): Unit

    @targetName("define")
    def <==(
      that: PROBE
    )(
      using Arena,
      Context,
      Block,
      LayerTree,
      sourcecode.File,
      sourcecode.Line
    ): Unit

  extension (ref: DATA)
    @targetName("resolve")
    def <==(
      that: PROBE
    )(
      using Arena,
      Context,
      Block,
      LayerTree,
      sourcecode.File,
      sourcecode.Line
    ): Unit
trait MonoConnect[D <: Data, SRC <: Referable[D], SINK <: Referable[D]]:
  extension (ref: SINK)
    def :=(
      that: SRC
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line
    ): Unit
trait Cvt[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def zext(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Neg[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def unary_!(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Not[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def unary_~(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait AndR[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def andR(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait OrR[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def orR(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait XorR[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def xorR(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Add[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def +(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Sub[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def -(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Mul[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def *(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Div[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def /(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Rem[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def %(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Lt[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def <(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Leq[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def <=(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Gt[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def >(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Geq[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def >=(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Eq[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def ===(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Neq[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def =/=(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait And[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def &(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Or[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def |(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Xor[D <: Data, RET <: Data, R <: Referable[D]]:
  extension (ref: R)
    def ^(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[RET]
trait Cat[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def ##(
      that: R
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[D]

trait Shl[D <: Data, THAT, OUT <: Data, R <: Referable[D]]:
  extension (ref: R)
    def <<(
      that: THAT
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[OUT]
trait Shr[D <: Data, THAT, OUT <: Data, R <: Referable[D]]:
  extension (ref: R)
    def >>(
      that: THAT
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[D]
trait Head[D <: Data, THAT, OUT <: Data, R <: Referable[D]]:
  extension (ref: R)
    def head(
      that: THAT
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[OUT]
trait Tail[D <: Data, THAT, OUT <: Data, R <: Referable[D]]:
  extension (ref: R)
    def tail(
      that: THAT
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[OUT]
trait Pad[D <: Data, THAT, OUT <: Data, R <: Referable[D]]:
  extension (ref: R)
    def pad(
      that: THAT
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[OUT]
trait ExtractRange[D <: Data, E <: Data, R <: Referable[D], IDX]:
  extension (ref: R)
    def bits(
      hi: IDX,
      lo: IDX
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[E]
trait ExtractElement[D <: Data, E <: Data, R <: Referable[D], IDX]:
  extension (ref: R)
    def bit(
      idx: IDX
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[E]
trait Mux[Cond <: Data, CondR <: Referable[Cond]]:
  extension (ref: CondR)
    def ?[Ret <: Data](
      con: Referable[Ret],
      alt: Referable[Ret]
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Node[Ret]
trait RefElement[D <: Data, E <: Data, R <: Referable[D], IDX]:
  extension (ref: R)
    def ref(
      idx: IDX
    )(
      using Arena,
      Context,
      Block,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine,
      InstanceContext
    ): Ref[E]
trait GetWidth[D <: Data, R <: Referable[D]]:
  extension (ref: R)
    def width(
      using Arena,
      Context
    ): Int

trait BitsApi[R <: Referable[Bits]]
    extends AsSInt[Bits, R]
    with AsUInt[Bits, R]
    with AsBool[Bits, R]
    with AsBundle[Bits, R]
    with AsRecord[Bits, R]
    with AsVec[Bits, R]
    with Not[Bits, Bits, R]
    with AndR[Bits, Bool, R]
    with OrR[Bits, Bool, R]
    with XorR[Bits, Bool, R]
    with Eq[Bits, Bool, R]
    with Neq[Bits, Bool, R]
    with And[Bits, Bits, R]
    with Or[Bits, Bits, R]
    with Xor[Bits, Bits, R]
    with Cat[Bits, R]
    with Shl[Bits, Int | Referable[UInt], Bits, R]
    with Shr[Bits, Int | Referable[UInt], Bits, R]
    with Head[Bits, Int, Bits, R]
    with Tail[Bits, Int, Bits, R]
    with Pad[Bits, Int, Bits, R]
    with ExtractElement[Bits, Bool, R, Int]
    with ExtractRange[Bits, Bits, R, Int]
    with GetWidth[Bits, R]

trait BoolApi[R <: Referable[Bool]]
    extends AsBits[Bool, R]
    with Neg[Bool, Bool, R]
    with Eq[Bool, Bool, R]
    with Neq[Bool, Bool, R]
    with And[Bool, Bool, R]
    with Or[Bool, Bool, R]
    with Xor[Bool, Bool, R]
    with Mux[Bool, R]
    with GetWidth[Bool, R]
trait UIntApi[R <: Referable[UInt]]
    extends AsBits[UInt, R]
    with Add[UInt, UInt, R]
    with Sub[UInt, UInt, R]
    with Mul[UInt, UInt, R]
    with Div[UInt, UInt, R]
    with Rem[UInt, UInt, R]
    with Lt[UInt, Bool, R]
    with Leq[UInt, Bool, R]
    with Gt[UInt, Bool, R]
    with Geq[UInt, Bool, R]
    with Eq[UInt, Bool, R]
    with Neq[UInt, Bool, R]
    with Shl[UInt, Int | Referable[UInt], UInt, R]
    with Shr[UInt, Int | Referable[UInt], UInt, R]
    with GetWidth[UInt, R]
trait SIntApi[R <: Referable[SInt]]
    extends AsBits[SInt, R]
    with Add[SInt, SInt, R]
    with Sub[SInt, SInt, R]
    with Mul[SInt, SInt, R]
    with Div[SInt, SInt, R]
    with Rem[SInt, SInt, R]
    with Lt[SInt, Bool, R]
    with Leq[SInt, Bool, R]
    with Gt[SInt, Bool, R]
    with Geq[SInt, Bool, R]
    with Neq[SInt, Bool, R]
    with Shl[SInt, Int | Referable[UInt], SInt, R]
    with Shr[SInt, Int | Referable[UInt], SInt, R]
    with GetWidth[SInt, R]

trait BundleApi[T <: Bundle | ProbeBundle, R <: Referable[T]] extends AsBits[T, R] with GetWidth[T, R]

trait RecordApi[T <: Record | ProbeRecord, R <: Referable[T]] extends AsBits[T, R] with GetWidth[T, R]

trait VecApi[E <: Data, V <: Vec[E], R <: Referable[V]]
    extends AsBits[V, R]
    with ExtractElement[V, E, R, Referable[UInt] | Int]
    with GetWidth[V, R]

trait ClockApi[R <: Referable[Clock]]

trait ResetApi[R <: Referable[Reset]] extends AsBool[Reset, R]

trait TypeImpl:
  extension (ref: Interface[?])
    private[zaozi] def operationImpl: Operation
    private[zaozi] def referImpl(
      using Arena
    ):                                Value
  extension (ref: Wire[?])
    private[zaozi] def operationImpl: Operation
    private[zaozi] def referImpl(
      using Arena
    ):                                Value
  extension (ref: Reg[?])
    private[zaozi] def operationImpl: Operation
    private[zaozi] def referImpl(
      using Arena
    ):                                Value
  extension (ref: Node[?])
    private[zaozi] def operationImpl: Operation
    private[zaozi] def referImpl(
      using Arena
    ):                                Value
  extension (ref: Ref[?])
    private[zaozi] def operationImpl: Operation
    private[zaozi] def referImpl(
      using Arena
    ):                                Value
  extension (ref: Const[?])
    private[zaozi] def operationImpl: Operation
    private[zaozi] def referImpl(
      using Arena
    ):                                Value
  extension (ref: Instance[?, ?])
    private[zaozi] def operationImpl:        Operation
    private[zaozi] def ioImpl[T <: Data]:    Wire[T]
    private[zaozi] def probeImpl[T <: Data]: Wire[T]

  extension (ref: Reset)
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ): Type
  extension (ref: Clock)
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ): Type
  extension (ref: UInt)
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ): Type
  extension (ref: SInt)
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ): Type
  extension (ref: Bits)
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ): Type
  extension (ref: Analog)
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ): Type
  extension (ref: Bool)
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ): Type
  extension (ref: ProbeBundle)
    def elements: Seq[BundleField[?]]
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ):            Type
    private[zaozi] def ReadProbeImpl[T <: Data & CanProbe](
      tpe:   T,
      layer: LayerTree
    )(
      using sourcecode.Name.Machine
    ):            BundleField[RProbe[T]]
    private[zaozi] def ReadWriteProbeImpl[T <: Data & CanProbe](
      tpe:   T,
      layer: LayerTree
    )(
      using sourcecode.Name.Machine
    ):            BundleField[RWProbe[T]]
  extension (ref: Bundle)
    def elements: Seq[BundleField[?]]
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ):            Type
    private[zaozi] def FlippedImpl[T <: Data](
      tpe: T
    )(
      using sourcecode.Name.Machine
    ):            BundleField[T]
    private[zaozi] def AlignedImpl[T <: Data](
      tpe: T
    )(
      using sourcecode.Name.Machine
    ):            BundleField[T]
  extension (ref: ProbeRecord)
    def elements: Seq[BundleField[?]]
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ):            Type
    private[zaozi] def ReadProbeImpl[T <: Data & CanProbe](
      name:  String,
      tpe:   T,
      layer: LayerTree
    ):            BundleField[RProbe[T]]
    private[zaozi] def ReadWriteProbeImpl[T <: Data & CanProbe](
      name:  String,
      tpe:   T,
      layer: LayerTree
    ):            BundleField[RWProbe[T]]
  extension (ref: Record)
    def elements: Seq[BundleField[?]]
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ):            Type
    private[zaozi] def FlippedImpl[T <: Data](
      name: String,
      tpe:  T
    ):            BundleField[T]
    private[zaozi] def AlignedImpl[T <: Data](
      name: String,
      tpe:  T
    ):            BundleField[T]
  extension (ref: RProbe[?])
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context,
      TypeImpl
    ): Type
  extension (ref: RWProbe[?])
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context,
      TypeImpl
    ): Type
  extension (ref: Vec[?])
    def elementType: Data
    def count:       Int
    private[zaozi] def toMlirTypeImpl(
      using Arena,
      Context
    ):               Type
  extension (ref: ProbeBundle)
    private[zaozi] def getRefViaFieldValNameImpl[E <: Data](
      refer:        Value,
      fieldValName: String
    )(
      using Arena,
      Block,
      Context,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine
    )(
      using TypeImpl
    ): Ref[E]
    private[zaozi] def getOptionRefViaFieldValNameImpl[E <: Data](
      refer:        Value,
      fieldValName: String
    )(
      using Arena,
      Block,
      Context,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine
    )(
      using TypeImpl
    ): Option[Ref[E]]
  extension (ref: Bundle)
    private[zaozi] def getRefViaFieldValNameImpl[E <: Data](
      refer:        Value,
      fieldValName: String
    )(
      using Arena,
      Block,
      Context,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine
    )(
      using TypeImpl
    ): Ref[E]
    private[zaozi] def getOptionRefViaFieldValNameImpl[E <: Data](
      refer:        Value,
      fieldValName: String
    )(
      using Arena,
      Block,
      Context,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine
    )(
      using TypeImpl
    ): Option[Ref[E]]

  extension (ref: ProbeRecord)
    private[zaozi] def getUntypedRefViaFieldValNameImpl(
      refer:        Value,
      fieldValName: String
    )(
      using Arena,
      Block,
      Context,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine
    )(
      using TypeImpl
    ): Ref[Data]

  extension (ref: Record)
    private[zaozi] def getUntypedRefViaFieldValNameImpl(
      refer:        Value,
      fieldValName: String
    )(
      using Arena,
      Block,
      Context,
      sourcecode.File,
      sourcecode.Line,
      sourcecode.Name.Machine
    )(
      using TypeImpl
    ): Ref[Data]
